

容器大致分为两类： sequence containers 和 associative containers

sequence containers序列式容器

- Array数组(C++11)
- Vector (类似单向可进的数组)
- Deque 双向队列(两端可进可出)
- List 双向链表
- Forward-List 单向链表(C++11)

associative containers关联式容器(key-value,适合快速的查找) 并没有规定要用那种结构去存储元素，但是因为红黑树性能很好，所以大部分编译器都使用红黑树实现

- Set /  Multiset

- Map / Multimap( Muti 意思即可以重复)

- unordered containers不定序容器(也是一种关联式容器，其实是用 hashTable 做的一个容器，C++11新出的一种容器) ，使用 HashTable Separate Chaining 即拉链法

  - unordered Set/Multiset
  - unordered Map/Multimap

  



vector内存的特性是只能往后扩展，往后扩展的方式是两倍扩展。

### List 

List 是双向链表

调用容器list自己的sort函数（**只有list和forward_list有自己的sort**）。

标准库也提供了一个全局的sort，**如果容器本身有sort，调用自己的sort比较快**。

#### forward_list

forward_list是单向链表，所以**没有push_back，只有push_front**

#### deque

- deque是分段连续。但使用者感觉是整个连续的。其结构类似一个 map, 每个 bucket 装载一个连续的链表, 每次扩充是按照一个bucket(buffer) 来的. 
-  涵盖了stack和queue的功能。
- 本身没有 sort。
- max_size 是各种容器中最大的

##### stack & queue

**需要注意的是:**

queue, stack 都是没有自己的数据结构，其实是**借用 deque **实现的。所以有人不把 stack 和 queue 叫做容器，而是叫做**容器的 adpater **。因为先进先出和先进后出的特性，所以他们并没有迭代器。



### Set / Map

- map可以用[] --> c[i] = string(buf); key没有重复，重复的是value ，所以size还是不会因为重复而减少

容器本身有 find, 元素放进去的时候会比较慢，但是后面的查找会非常快。

需要注意的是, insert 时 multimap不可使用{}, 应当使用 pair

```cpp
multimap<long, string> c;
c.insert(pair<long, string>(1, "aaa"));

map<long, string> c2;
aa.insert({1, "aaa"}); / c[1] = "aaa";
```

且对于 map, find 返回为 Iterator pair 不能打印, 需要使用`(*pItem).second`, 或者进行操作符重载.

```cpp
auto pItem = find(c.begin(), c.end(), target); //比c.find()慢很多
cout << "find(), milli-seconds : " << (clock() - timeStart) << endl;
if (pItem != c.end())
	cout << "found, " << (*pItem).second << endl;
```



#### multiset / multimap

底部是红黑树

#### unordered

底部是 HashTable 拉链法

